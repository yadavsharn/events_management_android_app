import 'dart:io';
import 'package:event_management_realtime/core/constants/app_constants.dart';
import 'package:event_management_realtime/core/error/failure.dart';
import 'package:event_management_realtime/core/utils/type_defs.dart';
import 'package:event_management_realtime/features/events/data/event_model.dart';
import 'package:event_management_realtime/features/events/data/event_remote_data_source.dart';
import 'package:event_management_realtime/features/events/domain/event_entity.dart';
import 'package:event_management_realtime/features/events/domain/event_repository.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fpdart/fpdart.dart';
import 'package:hive/hive.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

final eventRepositoryProvider = Provider<EventRepository>((ref) {
  return EventRepositoryImpl(
    ref.watch(eventRemoteDataSourceProvider),
    Hive.box<EventModel>(AppConstants.eventsTable),
  );
});

class EventRepositoryImpl implements EventRepository {
  final EventRemoteDataSource _remoteDataSource;
  final Box<EventModel> _box;

  const EventRepositoryImpl(this._remoteDataSource, this._box);

  @override
  FutureEither<EventEntity> createEvent({
    required String title,
    required String description,
    required String location,
    required DateTime startTime,
    required DateTime endTime,
    required List<File> images,
    File? video,
  }) async {
    try {
      final eventModel = EventModel(
        id: '', // Generated by DB
        title: title,
        description: description,
        location: location,
        startTime: startTime,
        endTime: endTime,
        createdBy: Supabase.instance.client.auth.currentUser!.id,
        images: const [], // Will be filled by DS
        attendeesCount: 0,
        status: 'upcoming',
      );

      final result = await _remoteDataSource.createEvent(
        event: eventModel,
        images: images,
        video: video,
      );
      
      // Cache the new event
      _box.put(result.id, result);
      
      return right(result);
    } on Failure catch (e) {
      return left(e);
    } catch (e) {
      return left(ServerFailure(e.toString()));
    }
  }

  @override
  FutureEither<void> deleteEvent(String eventId) async {
    try {
      await _remoteDataSource.deleteEvent(eventId);
      _box.delete(eventId);
      return right(null);
    } on Failure catch (e) {
      return left(e);
    } catch (e) {
      return left(ServerFailure(e.toString()));
    }
  }

  @override
  FutureEither<List<EventEntity>> getEvents() async {
    try {
      // Try fetching from network
      final events = await _remoteDataSource.getEvents();
      
      // Update cache
      for (var event in events) {
        _box.put(event.id, event);
      }
      
      return right(events);
    } catch (e) {
      // If network fails, try cache
      if (_box.isNotEmpty) {
        return right(_box.values.toList());
      }
      return left(ServerFailure(e.toString()));
    }
  }

  @override
  Stream<List<EventEntity>> getEventsStream() {
    return _remoteDataSource.getEventsStream().map((events) {
      // Update cache on stream update
      for (var event in events) {
        _box.put(event.id, event);
      }
      return events;
    });
  }

  @override
  FutureEither<void> markInterested(String eventId) async {
    try {
      await _remoteDataSource.markInterested(eventId);
      return right(null);
    } on Failure catch (e) {
      return left(e);
    } catch (e) {
      return left(ServerFailure(e.toString()));
    }
  }
}
